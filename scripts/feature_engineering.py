"""
scripts/feature_engineering.py

This module handles the transformation of data into features for classification.
This file replaces the old compute_ig.py.

Core Responsibilities:
1.  Compute Intercept (R0) and Gradient (G) pairs from the synthetic
    reflectivity (Rpp) curves generated by the simulation.
2.  Format the *real* seismic data (Intercept, Gradient) into an
    (N, 2) feature array for classification.
3.  Provide generic helper functions to save/load these computed files.
"""

import numpy as np
import pickle

# ==============================================================================
#   Generic Save/Load Functions
# ==============================================================================

def save_computed_data(data, output_path):
    """
    Saves computed data (e.g., AVO curves, feature arrays) to a .pkl file.
    
    Args:
        data (any): The python object to pickle.
        output_path (str): The full file path to save the .pkl file to.
    """
    try:
        with open(output_path, 'wb') as f:
            pickle.dump(data, f)
        print(f"  Successfully saved computed data to: {output_path}")
    except Exception as e:
        print(f"  Error saving data to {output_path}: {e}")

def load_computed_data(file_path):
    """
    Loads cached computed data from a .pkl file.

    Args:
        file_path (str): The full file path to the .pkl file.

    Returns:
        any: The loaded python object.
        
    Raises:
        FileNotFoundError: If the file does not exist.
        Exception: For other pickle/loading errors.
    """
    print(f"  Attempting to load cached data from: {file_path}")
    with open(file_path, 'rb') as f:
        data = pickle.load(f)
    print(f"  Successfully loaded cached data.")
    return data

# ==============================================================================
#   Intercept & Gradient Computation (from Synthetic Data)
# ==============================================================================

def compute_intercept_gradient(avo_data_map):
    """
    Calculates Intercept (R0) and Gradient (G) for all reflectivity curves
    using the Shuey 2-term approximation: R(theta) = R0 + G*sin^2(theta).
    
    This is achieved by a 1st-degree polynomial fit (linear regression)
    where:
        y = Rpp curve
        x = sin^2(theta)
        The fit returns [m, c] which corresponds to [Gradient, Intercept].

    Args:
        avo_data_map (dict): The dictionary loaded from 'avo_data.pkl',
                             e.g., {'FaciesIIa': {'angles': [...], 'Rpp': [...]}}

    Returns:
        dict: A dictionary containing the computed Intercept and Gradient
              arrays for each facies.
              e.g., {'FaciesIIa': {'intercept': [...], 'gradient': [...]}}
    """
    print("Computing Intercept (R0) and Gradient (G) from synthetic data...")
    
    intercept_gradient_data = {}
    x_data = None # This will be sin^2(theta)
    
    for facies_name, facies_data in avo_data_map.items():
        
        if 'angles' not in facies_data or 'Rpp' not in facies_data:
            print(f"  Warning: Skipping {facies_name}, missing 'angles' or 'Rpp'.")
            continue
            
        # On the first valid facies, calculate the x-axis (sin^2(theta))
        if x_data is None:
            theta_deg = facies_data['angles']
            theta_rad = np.deg2rad(theta_deg)
            x_data = np.sin(theta_rad)**2
        
        curves = facies_data['Rpp'] # Shape: (n_simulations, n_angles)
        
        intercepts = []
        gradients = []
        
        # Loop through each individual reflectivity curve (each simulation)
        for curve in curves:
            # np.polyfit(x, y, 1) returns [m, c] which is [G, R0]
            try:
                G, R0 = np.polyfit(x_data, curve, 1)
                intercepts.append(R0)
                gradients.append(G)
            except (np.linalg.LinAlgError, ValueError) as e:
                # Handle cases where polyfit fails (e.g., NaN in curve)
                intercepts.append(np.nan)
                gradients.append(np.nan)

        # Store results for this facies
        intercept_gradient_data[facies_name] = {
            'intercept': np.array(intercepts),
            'gradient': np.array(gradients)
        }
        print(f"  Computed [I, G] pairs for: {facies_name}")

    if x_data is None:
        print("Error: No valid facies data was found to process.")
        return None

    print("Intercept/Gradient computation complete.")
    return intercept_gradient_data

# ==============================================================================
#   Seismic Feature Formatting (from Real Data)
# ==============================================================================

def format_seismic_features(seismic_data_map):
    """
    Formats the *real* seismic data into an (N, 2) [Intercept, Gradient]
    feature array for classification.

    Args:
        seismic_data_map (dict): The dictionary of seismic data loaded
                                 from load_raw_data (e.g., raw_data['seismic']).

    Returns:
        np.ndarray: An (N, 2) array where N is the total number of
                    data points. Column 0 is Intercept, Column 1 is Gradient.
                    Returns None if data is missing or shapes mismatch.
    """
    print("Formatting real seismic data into feature array...")
    
    try:
        intercept = seismic_data_map['intercept']
        gradient = seismic_data_map['gradient']
    except KeyError:
        print("  Error: 'intercept' or 'gradient' not found in raw seismic data.")
        return None
        
    if intercept.shape != gradient.shape:
        print(f"  Error: Shape mismatch. Intercept is {intercept.shape}, Gradient is {gradient.shape}.")
        return None
        
    # Flatten the 2D seismic maps into 1D arrays
    intercept_flat = intercept.flatten()
    gradient_flat = gradient.flatten()
    
    # Stack them into an (N, 2) array
    # We use axis=1 to get shape (N, 2)
    seismic_features = np.stack((intercept_flat, gradient_flat), axis=1)
    
    print(f"  Successfully formatted seismic features. Shape: {seismic_features.shape}")
    return seismic_features