"""
Compare the statistics being generated by new code vs what the old code would generate.
The key question: Are the mean_vector values different between old and new?
"""
import numpy as np
import pickle

print("="*80)
print("CHECKING IF STATISTICS MATCH ORIGINAL WORKFLOW")
print("="*80)

# Load the rock property stats (used for MC sampling)
with open('computed/rock_property_statistics.pkl', 'rb') as f:
    rock_stats = pickle.load(f)

# Load the I/G data (synthetic training)
with open('computed/intercept_gradient_data.pkl', 'rb') as f:
    ig_data = pickle.load(f)

FACIES_NAMES = [
    'FaciesIIaOil', 'FaciesIIbOil', 'FaciesIIcOil',
    'FaciesIIa',     'FaciesIIb',     'FaciesIIc',
    'FaciesIII',     'FaciesIV',      'FaciesV'
]

print("\n1. CHECKING BIVARIATE MEAN_VECTOR vs UNIVARIATE MEANS")
print("-"*80)
print("The mean_vector should MATCH the univariate means (original workflow)")
print()
print(f"{'Facies':<15} {'MeanVec[0]':>11} {'Univ_Vp':>11} {'Match?':>8} | {'MeanVec[1]':>11} {'Univ_Vs':>11} {'Match?':>8}")
print("-"*80)

all_match = True
for name in FACIES_NAMES:
    if name not in rock_stats:
        continue
    
    mean_vec = rock_stats[name]['bivariate_VpVs']['mean_vector']
    vp_mean = rock_stats[name]['univariate']['Vp']['mean']
    vs_mean = rock_stats[name]['univariate']['Vs']['mean']
    
    vp_match = np.isclose(mean_vec[0], vp_mean, rtol=1e-6)
    vs_match = np.isclose(mean_vec[1], vs_mean, rtol=1e-6)
    
    if not (vp_match and vs_match):
        all_match = False
    
    print(f"{name:<15} {mean_vec[0]:11.6f} {vp_mean:11.6f} {'✓' if vp_match else 'X':>8} | "
          f"{mean_vec[1]:11.6f} {vs_mean:11.6f} {'✓' if vs_match else 'X':>8}")

if all_match:
    print("\n✓ All mean_vectors match univariate means (CORRECT)")
else:
    print("\n✗ MISMATCH DETECTED - This could cause wrong Monte Carlo samples!")

# 2. Check the actual I/G values for FaciesIIaOil specifically
print("\n2. FACIESIIAOIL DETAILED CHECK")
print("-"*80)

if 'FaciesIIaOil' in ig_data:
    oil_i = ig_data['FaciesIIaOil']['intercept']
    oil_g = ig_data['FaciesIIaOil']['gradient']
    
    # Clean
    mask = np.isfinite(oil_i) & np.isfinite(oil_g)
    oil_i_clean = oil_i[mask]
    oil_g_clean = oil_g[mask]
    
    print(f"Intercept: mean={np.mean(oil_i_clean):.4f}, std={np.std(oil_i_clean):.4f}")
    print(f"Gradient:  mean={np.mean(oil_g_clean):.4f}, std={np.std(oil_g_clean):.4f}")
    print(f"Valid samples: {len(oil_i_clean)} / {len(oil_i)}")
    
    # Compare to seismic data
    with open('computed/seismic_features.pkl', 'rb') as f:
        seismic = pickle.load(f)
    
    seismic_clean = seismic[~np.any(np.isnan(seismic), axis=1)]
    seismic_i_mean = np.mean(seismic_clean[:, 0])
    seismic_g_mean = np.mean(seismic_clean[:, 1])
    
    print(f"\nSeismic Data:")
    print(f"Intercept: mean={seismic_i_mean:.4f}")
    print(f"Gradient:  mean={seismic_g_mean:.4f}")
    
    print(f"\nDistance from FaciesIIaOil mean to Seismic mean:")
    oil_mean = np.array([np.mean(oil_i_clean), np.mean(oil_g_clean)])
    seismic_mean = np.array([seismic_i_mean, seismic_g_mean])
    dist = np.linalg.norm(oil_mean - seismic_mean)
    print(f"Euclidean Distance: {dist:.4f}")
    
    # How much overlap?
    print(f"\nOverlap Analysis:")
    seismic_i_range = (np.percentile(seismic_clean[:, 0], 5), np.percentile(seismic_clean[:, 0], 95))
    seismic_g_range = (np.percentile(seismic_clean[:, 1], 5), np.percentile(seismic_clean[:, 1], 95))
    
    oil_in_i_range = np.sum((oil_i_clean >= seismic_i_range[0]) & (oil_i_clean <= seismic_i_range[1]))
    oil_in_g_range = np.sum((oil_g_clean >= seismic_g_range[0]) & (oil_g_clean <= seismic_g_range[1]))
    oil_in_both = np.sum(
        (oil_i_clean >= seismic_i_range[0]) & (oil_i_clean <= seismic_i_range[1]) &
        (oil_g_clean >= seismic_g_range[0]) & (oil_g_clean <= seismic_g_range[1])
    )
    
    print(f"Seismic I range (5-95%): [{seismic_i_range[0]:.4f}, {seismic_i_range[1]:.4f}]")
    print(f"Seismic G range (5-95%): [{seismic_g_range[0]:.4f}, {seismic_g_range[1]:.4f}]")
    print(f"FaciesIIaOil samples in I range: {100*oil_in_i_range/len(oil_i_clean):.1f}%")
    print(f"FaciesIIaOil samples in G range: {100*oil_in_g_range/len(oil_g_clean):.1f}%")
    print(f"FaciesIIaOil samples in BOTH ranges: {100*oil_in_both/len(oil_i_clean):.1f}%")

# 3. Check if the old code would have produced different results
print("\n3. SIMULATING OLD CODE BEHAVIOR")
print("-"*80)

# The old code computed bivariate stats differently
# Let's check what would happen with the original approach
from scripts.load_data import load_raw_data
import config

print("Loading raw facies data to recompute stats the OLD way...")
raw_data = load_raw_data(
    facies_dir=config.FACIES_DIR,
    facies_column_names=config.FACIES_COLUMN_NAMES,
    seismic_paths=config.SEISMIC_FILE_PATHS,
    well_path=config.WELL_FILE_PATH,
    well_column_names=config.WELL_COLUMN_NAMES
)

if 'FaciesIIaOil' in raw_data['facies']:
    facies_obj = raw_data['facies']['FaciesIIaOil']
    
    vp_data = facies_obj.Vp
    vs_data = facies_obj.Vs
    
    # OLD WAY: Clean each independently, then truncate
    vp_clean_old = vp_data[np.isfinite(vp_data)]
    vs_clean_old = vs_data[np.isfinite(vs_data)]
    min_len_old = min(len(vp_clean_old), len(vs_clean_old))
    vp_clean_old = vp_clean_old[:min_len_old]
    vs_clean_old = vs_clean_old[:min_len_old]
    
    # Compute covariance from truncated data
    vp_vs_stack_old = np.stack((vp_clean_old, vs_clean_old), axis=0)
    cov_old = np.cov(vp_vs_stack_old)
    
    # Compute means from truncated data (BUG in your new code if this was done)
    mean_vec_old_buggy = np.array([np.mean(vp_clean_old), np.mean(vs_clean_old)])
    
    # NEW WAY (CORRECT): Means from full data
    vp_clean_new = vp_data[np.isfinite(vp_data)]
    vs_clean_new = vs_data[np.isfinite(vs_data)]
    mean_vec_new_correct = np.array([np.mean(vp_clean_new), np.mean(vs_clean_new)])
    
    print(f"\nFaciesIIaOil bivariate statistics comparison:")
    print(f"Mean Vector (old buggy way):  Vp={mean_vec_old_buggy[0]:.6f}, Vs={mean_vec_old_buggy[1]:.6f}")
    print(f"Mean Vector (new correct way): Vp={mean_vec_new_correct[0]:.6f}, Vs={mean_vec_new_correct[1]:.6f}")
    print(f"Mean Vector (current in file):  Vp={rock_stats['FaciesIIaOil']['bivariate_VpVs']['mean_vector'][0]:.6f}, "
          f"Vs={rock_stats['FaciesIIaOil']['bivariate_VpVs']['mean_vector'][1]:.6f}")
    
    if np.allclose(rock_stats['FaciesIIaOil']['bivariate_VpVs']['mean_vector'], mean_vec_old_buggy):
        print("\n⚠ WARNING: Current stats match OLD BUGGY behavior!")
        print("   The mean_vector is computed from TRUNCATED data instead of full data.")
    elif np.allclose(rock_stats['FaciesIIaOil']['bivariate_VpVs']['mean_vector'], mean_vec_new_correct):
        print("\n✓ Current stats match CORRECTED behavior")

print("\n" + "="*80)
print("DIAGNOSTIC COMPLETE")
print("="*80)